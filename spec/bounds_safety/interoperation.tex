% !Tex root = checkedc.tex

\newcommand{\dynamicboundscast}{\texttt{dynamic\_bounds\_cast}}
\newcommand{\dynamicboundscastinst}[2]{\texttt{dynamic\_bounds\_cast<#1>#2}}
\newcommand{\assumeboundscast}{\texttt{assume\_bounds\_cast}}
\newcommand{\assumeboundscastinst}[2]{\texttt{assume\_bounds\_cast<#1>#2}}

\newcommand{\boundscast}[2]{\texttt{bounds\_cast<#1>#2}}
\newcommand{\coreboundscast}[2]{\texttt{core\_bounds\_cast<#1>#2}}
\newcommand{\ptrcast}[2]{\texttt{bounds\_cast<#1>#2}}

\chapter{Interoperation}
\label{chapter:interoperation}

Code that uses safe pointer types must be able to interoperate with
code that uses unsafe pointer types.  This chapter describes support
for this.  Section~\ref{section:pointer-casting} starts with
conversion operations: how different kinds of pointers can
be converted to other kinds of pointers.  
Section~\ref{section:function-bounds-safe-interfaces}
describes how existing code that uses unsafe pointers can be modified
to present a safe interface.  They key insight there is that the
the interface must be both safe and unsafe, depending on context.
For existing code that uses unsafe pointers, the interface is descriptive,
but correctness is not enforced by the language.  For code that uses safe
pointers, proper usage of the interface is checked and enforced.

\section{Conversions between pointers to objects of different types}
\label{section:pointer-casting}

Conversions from a pointer to one type to a pointer to a different type
introduce two issues. First, there is type safety. Given a pointer to S
that has been converted to be a pointer to T, is it valid to treat the
memory pointed to by the pointer as being an object of type T instead of
type S? Second, there is bounds safety. Given the pointer, what range of
memory can be accessed validly using that pointer? This section focuses on
bounds safety.

Type safety is not addressed by this technical report. Of course, violating
type safety can lead to violations of bounds safety. This can happen
when there is a conversion between a safe pointer to an object of
structure type that contains a bounds-checked member and a safe pointer
to an object of another type. A programmer can use the pointer to the
other type to modify the bounds-checked member or its bounds in an
inconsistent fashion. For now, it is the programmer's responsibility to
update bounds-checked members and their bounds properly when using a
safe pointer that results from such a conversion. Conversions between
safe pointers to integral types, floating-point types, or structures that
contain only integral types or floating-point types cannot lead to
violations of bounds safety by themselves.

\subsection{Cast operators}
This section describes casts to pointer types.
A conversion of a value from one safe pointer type to a value of another safe
pointer type is valid when the following rules hold:
\begin{itemize}
\item If the destination pointer is a \ptrT\ type, the range of 
memory that can be accessed beginning at the source pointer is
large enough to hold a value of type \var{T}.
\item If the destination pointer is a \arrayptrT\ or \arrayviewT type, 
the bounds for the destination pointer are equal to or within the range of
the memory accessible through the source pointer.
\end{itemize}

Casts between safe pointer types should preserve bounds safety
by default.  The cases where it does not should be the unusual cases.
For this reason, C cast operations to safe pointer types are 
required to be provably safe at compile-time.   We add two new
operators for other cases.  Table~\ref{table:cast-operators}
describes the operators.

\begin{table}
\begin{tabular}{p{1.5in}p{4in}}
\toprule
Operator & Description \\
\texttt{(T *)} & The C cast operator.  Additional static checking rules
ensure pointer casts to safe pointer types are safe with respect to bounds.\\
\dynamicboundscast\ & Does dynamic checks to enforce bounds
safety.  It produces a runtime error if the checks fail.\\
\assumeboundscast\ & Declares new bounds for the value that are trusted without verification.  
Because it is unsafe, it is not allowed in \keyword{checked} blocks.\\
\bottomrule
\end{tabular}
\caption{Cast operators for pointer types}
\label{table:cast-operators}
\end{table}

The syntax of the new operators is similar to the syntax of C++ type
conversion operators, where the destination pointer type is specified by
placing a type argument \texttt{<\var{T}>} after the operator: \dynamicboundscastinst{\var{T}}{}
and \assumeboundscastinst{\var{T}}{}.   A relative alignment type or constant can be
specified using an optional second argument:  
\dynamicboundscastinst{\var{T}, \var{A}}{} or \assumeboundscastinst{\var{T, \var{A}}}{}.
Of course, macro-like syntax could be used as well.

For C cast operations from safe pointer types to unsafe pointer types,
it is not possible to prove that they are safe at compile-time.   At the same
time, it is desirable catch the programming error of converting an out-of-range
safe pointer to an unsafe pointer and then trying to use the unsafe
pointer to access memory.  For this reason, we take the stance that if the
destination pointer is a \unsafeptrT\ type, the range of memory that can be accessed
beginning at the safe pointer should be provably large enough at compile time 
to hold a value of type \var{T}.

C does allow an unsafe pointer to point one element past the end of an array.
However, it is illegal to dereference that pointer.  This case mainly arises
from loops that stride through an array and end up creating a pointer one past
an element of an array.  It would be unusual for a programmer to
convert a safe pointer to an unsafe pointer and then stride downwards through an array, 
predecrementing the pointer.  Because of that, C cast operations from safe pointer
types to unsafe pointer types that would create a pointer one element past
the end of the array pointed to by the safe pointer are rejected at compile time.
A programmer may use an \assumeboundscast\ operation do this instead.

\subsection{Static and runtime checking rules}

Here are the static checking rules for C cast operations of the form \texttt{(\var{D}) \var{e}},
where \var{e} has source type \var{S}. If
\var{D} is not \ptrvoid\ or \unsafeptrvoid\ and \var{D} is

\begin{itemize}
\item \ptrT: the bounds of \var{e} are computed using the rules
in Section~\ref{section:checking-nested-assignment-expressions}.
\begin{itemize}
\item If the bounds are \boundsnone, checking fails with a compile-time
error.
\item Otherwise, if the bounds are \boundsany, checking 
succeeds.
\item Otherwise, the bounds must be \bounds{\var{lb}}{\var{ub}} (or convertible
to that form).  It must be statically provable that \texttt{\var{e} >= \var{lb}}
and that {\texttt{((char *) \var{ub}) - ((char *) e) >= sizeof(\var{T})}}.    
\end{itemize}
\item \arrayptrT: No new rules are needed.   The rules in
Chapter~\ref{chapter:checking-bounds} already cover this case.
\item \arrayviewT: It must be statically provable that \var{e}
and \bounds{lb}{ub} meet the relative alignment requirements of
the destination \arrayview\ type.  At runtime, a new value of
type \arrayviewT\ with the value of \var{e} and \bounds{lb}{ub} will be created.
\item \texttt{\var{T} *}: If the source type \var{S} is
\begin{itemize}
\item An unsafe pointer type (\texttt{*}), checking succeeds.
\item \ptrT, the checking succeeds. This handles the case where \var{T}
is an incomplete type.
\item Otherwise, the same rules are followed as for \ptrT.
\end{itemize}
\end{itemize}

If \var{D} is \ptrvoid\ or \unsafeptrvoid\ and \var{S} is:
\begin{itemize}
\item A \ptr\ type, static checking always succeeds.
\item An \arrayptr\ or \arrayview\ type: The bounds of \var{e} are computed:
\begin{itemize}
\item If the resulting bounds are \boundsnone, checking fails with a compile-time
error.
\item Otherwise, if the result bounds are \boundsany, checking 
succeeds.
\item Otherwise, the result must be \bounds{\var{lb}}{\var{ub}} (or convertible
to that form).   It must be statically provable that \texttt{\var{e} >= \var{lb}}
and that {\texttt{((char *) \var{ub}) - ((char *) e) >= 1}}.   
\end{itemize}
\end{itemize}

The \dynamicboundscast\ operator is not strictly needed.
Programmers could write checks by hand.  However, programmers
would have to compute the bounds of expressions by hand too, so it is convenient to
have it. It takes 1 to 3 arguments, depending on the kind of conversion being done:
\begin{itemize}
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1})}
  converts \var{e1} to either a \ptr\ or * type.
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1},
  \var{e2})} converts \var{e1} to an \arrayptr\ or
  \arrayview\ type with bounds \boundscount{\var{e2}}.  
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1},\var{e2},\var{e3})} converts \var{e1} to an
  \arrayptr\ or \arrayview\ type with bounds
  \bounds{\var{e2}}{\var{e3}}.  \dynamicboundscastinst{\var{T}, \var{A}}
  {(\var{e1},\var{e2},\var{e3})}
   optionally changes the relative alignment of the bounds to \var{A}.
\end{itemize}

Here is the checking that is done. The bounds of \var{e1} are computed
using the rules in Section~\ref{section:checking-nested-assignment-expressions}.
If the bounds of \var{e1} are \boundsnone, it is a compile-time error. 
If the bounds of \var{e1} are \boundsany, no runtime checks are needed.
Otherwise the bounds must be \bounds{\var{lb}}{\var{ub}} (or convertible to that form).
The following runtime checks are done:
\begin{itemize}
\item Check whether \var{e1} is 0.  If so, no further runtime checking
is needed.
\item Otherwise, if the operator has the form:
\begin{itemize}
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1})}:
  check that there is room for least one element of \var{T} by doing the
  the check for \dynamicboundscastinst{\var{T}}{(e1, 1)}.
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1}, \var{e2})}:
   check that \var{lb}
  \texttt{<=} \var{e1} \texttt{\&\&} \var{e1} \texttt{+
  sizeof(referent-type(}\var{T}\texttt{)) *} e2 \texttt{<=}
  \var{ub}.
\item
  \dynamicboundscastinst{\var{T}}{(\var{e1},\var{e2},\var{e3})}: 
  check that \var{lb} \texttt{<=} \var{e2} \texttt{\&\&}
  \var{e3} \texttt{<=} \var{ub}. Also check that \var{e1}, \var{e2}, and \var{e3} 
  are relatively aligned to \var{T} (or the optional alignment parameter instead, if one
  is given). 

\end{itemize}
\end{itemize}

The operator \assumeboundscastinst{\var{T}}{} declares bounds that are trusted
without verification:
\begin{itemize}
\item
  \assumeboundscastinst{\var{T}}{(\var{e1},\var{e2})}
  converts \var{e1} to an \arrayptr\ or
  \arrayview\ type with \boundscount{\var{e2}}
\item
  \assumeboundscastinst{\var{T}}{(\var{e1},\var{e2},\var{e3})}
  converts \var{e1} to an
  \arrayptr\ or \arrayview\ type with \bounds{\var{e2}}{\var{e3}}.
  It must be statically provable that \var{e1}, \var{e2} and \var{e3}
  are relatively aligned for \var{T} (or the optional
  relative alignment parameter instead, if there is one).
\item
  \assumeboundscastinst{\var{T}}{(\var{e1})}
  converts \var{e1} to a \ptr\ or \texttt{*} type.
\end{itemize}

If any rule depends on \texttt{sizeof(\var{T})} and \var{T} is
an incomplete type, the cast operation that uses the rule shall fail
to check at compile-time.

A subtle point about the C cast operator and \dynamicboundscast
are that they allow {\em bounds-safe casts} of an expression
\var{e} of unsafe pointer type to an \arrayview\ or
\arrayptr\ type. This is provided that the bounds for \var{e}
can be determined. Only a few kinds of expressions with unsafe pointer
types have bounds that can be determined: address-of expressions
involving variables and uses of array variables.

\subsection{Implicit conversions}
\label{section:implicit-conversions}

Implicit conversions from unsafe pointer types to safe pointer types with the 
same referent type are allowed during type checking.  The rules for
bounds checking are applied separately after type checking and are relied upon 
to guarantee the bounds-safety of the implicit conversions.  In each case, the 
implicit conversion is  equivalent to an insertion of a C cast operator to the desired
safe pointer type  at that program point. 

Implicit conversions  from \unsafeptrvoid\ to safe pointer types are also 
allowed for now.  There is not a  design for checking type-safety of casts yet.  
The design will almost certainly affect \unsafeptrvoid\ casts. We wish to avoid
requiring changes to code that might have to be altered a second time.  Only
one implicit pointer conversion is allowed for an expression.  An expression will not be
coerced implicitly from \unsafeptrinst{\var{S}} to \unsafeptrvoid\ to
\unsafeptrinst{\var{T}}, where S and T are types.

\section{Bounds-safe interfaces to existing unsafe functions and variables}
\label{section:function-bounds-safe-interfaces}

The new pointer types capture specific properties of pointers. One would
like to update existing C code to use these new pointer types. However,
this will not be possible when backward compatibility requirements
exist. Consider C runtime functions or OS APIs. It may be feasible to
modify the header files for the runtime function or OS API. It may be
impossible to require all uses of these functions or APIs be updated.
Code written by 3\textsuperscript{rd} parties may use these APIs and it
is not reasonable for an existing shipping OS to require all
3\textsuperscript{rd} parties update their existing code to use the new
types.

Consider what would happen if the signature for memcpy were updated to
use \arrayptr. The function

\begin{verbatim}
void *memcpy(void *dest, const void *src, size_t count);
\end{verbatim}

becomes

\begin{verbatim}
void *memcpy(array_ptr<void> dest, array_ptr<const void> src, size_t count);
\end{verbatim}

This, of course, breaks every piece of existing code that uses memcpy.
The code will no longer compile. C does not have method overloading, so
one cannot simply define multiple overloaded versions of memcpy. That
would also be duplicative and potentially increase program sizes.

The reverse problem also exists: suppose the signature for memcpy is not
updated. Then every ``safe'' method that calls memcpy would need to cast
the arguments to unsafe pointer types.

Given that we may not be able to change the pointer types of existing
APIs, we need to adopt an approach that supports backwards
compatibility, enables new safe code to be written easily, and maintains
the safety of new code.

We address this by:

\begin{enumerate}
\item
  Allowing programmers to declare bounds-safe interfaces to code and
  data structures that use unsafe pointers. A bounds-safe interface for
  a function, for example, describes bounds for unsafe pointer
  parameters.   Type checking is altered to insert implicit conversions
  for pointer types when needed.
\item
  In checked scopes, code is limited to using pointer types that are 
  safe pointer types or that have bounds-safe interfaces.  This makes the code
  in those scopes straightforward to understand: the unsafe pointer types can
  be regarded as safe pointer types, all memory accesses are
  bounds checked or in bounds, and bounds-safe interfaces are trusted
  and respected.
\item
  In unchecked scopes, safe and unsafe pointer types can be
  be intermixed.  The decision about enforcing bounds-safe interfaces 
  is made based on context.  Given an expression where both safe and
  unsafe pointer types occur, bounds-safety is enforced in the expression
  and any subexpressions, assuming that the bounds-safe interface is
  correct.
\end{enumerate}

Functions that have parameters with unsafe pointer types or that return
values with unsafe pointer types can have bounds declared for the unsafe
pointer parameters or the unsafe pointer return value. Bounds must be
declared for all parameters with unsafe pointer types and the return
value, if it has an unsafe pointer type. In the case where a parameter
has \texttt{ptr} type, this can be declared specially.

Here is the bounds-safe interface for memcpy:
\begin{verbatim}
void *memcpy(void *dest : count(len), const void *src : count(len), size_t len)
where return_value : bounds(dest, dest + count)
\end{verbatim}

The correctness of bounds information is enforced at compile-time when
memcpy is passed safe pointer arguments. It is not enforced when memcpy
is passed unsafe pointer arguments.

Similarly, for data structures, members with unsafe pointer types can
have bounds declared. If bounds are declared for one member of a
structure with an unsafe pointer type, they must be declared for all
members with unsafe pointer types.

Here are the bounds for a structure that is a counted buffer of
characters.
\begin{verbatim}
struct S {
     char *arr : count(len);
     int len;
}
\end{verbatim}

We may have a method that takes a counted buffer of characters and
counts the number of instances of a specific character. The \texttt{ptr}
declaration can be used to declare an unsafe pointer to a singleton
object of a type:
\begin{verbatim}
int count_char(S *str where ptr, char arg);
\end{verbatim}

Variables at external scope with unsafe pointer types may also have 
bounds declared for them.   The declarations must follow the 
rules in Section~\ref{section:external-scope-variables}.

It is important to understand that the \emph{semantics of unsafe
pointers does not change in unchecked scopes even when bounds are
declared for the pointers}. The declared bounds are used only when checking the
validity of bounds in code that uses safe pointer types.  
Unsafe pointer dereferences do not have bounds checks added to them. A function
that declares a bounds-safe interface and whose body does not use safe pointer
types is compiled as though the bounds-safe interface has been
stripped from its source code.

\subsection{Type checking}

Bounds-safe interfaces allow unsafe pointer types to be used
where safe pointer types with the same referent type are expected and {\it vice versa}.
To handle this, implicit pointer conversions are inserted during type checking to handle this.  
As discussed in Section~\ref{section:implicit-conversions}, 
implicit conversions from unsafe pointer types to safe types are already allowed.

Implicit conversions from safe pointer types to unsafe pointer types
with the same referent types are allowed exactly at the use of a variable or 
function with a  bounds-safe interface.  In each case, the conversion is equivalent
to insertion of a C cast operator to the desired unsafe type.  They
are allowed at:
\begin{itemize}
\item Function calls: If the function being called has a bounds-safe interface for unsafe
    pointer type arguments and a parameter type has type \unsafeptrT and the corresponding
    argument expression has a safe pointer to \var{T} type, the argument expression will
    be implicitly converted to \unsafeptrT.
 item Assignment to a variable with external scope: if the variable has
    the type \unsafeptrT\ and a bounds-safe interface and the right-hand side has
    safe pointer type to \var{T}, the right-hand side has a safe pointer to
    \var{T} type, the right-hand side will be implicitly converted to \unsafeptrT.
\item
   Member assignment: if the left-hand member has type \unsafeptrT\ and a bounds-safe
   interface, and the right-hande side has a safe pointer to \var{T} type, the
   right-hand side will be implicitly converted to \unsafeptrT.
   \var{T}.
  type.
\end{itemize}

Implicit conversions are allowed from safe pointer types to unsafe pointer
types of type \unsafeptrvoid, for the same reason that implicit conversions
are allowed from type \unsafeptrvoid.  Only one implicit pointer conversion
is allowed for an expression.

\subsection{Checking bounds declarations}

The checking machinery in Chapter~\ref{chapter:checking-bounds} requires
only small changes to check code with bounds-safe interfaces.  The
checking is done after any implicit pointer conversions have been
inserted.

An expression uses both safe pointer types and unsafe pointer types if
both kinds of types occur as types of subexpressions or occur directly
as subexpressions (for example, in a cast operator).

At any point in Chapter~\ref{chapter:checking-bounds} where the
bounds of an expression must be inferred, if an expression uses both
kinds of pointer types,
\begin{itemize}
\item The rules for inferring bounds of expressions 
(Section~\ref{section:inferring-expression-bounds}) are 
extended:
\begin{enumerate}
\item Uses of variables (Section~\ref{section:checking-variables}): 
      if a variable with an unsafe pointer type is used and the variable has
      a bounds-safe interface, the bounds from that interface are used as the bounds
      for the variable.
\item Function calls (Section~\ref{section:checking-function-call-arguments}):  the rules
      in this section are applied if the function returns an unsafe pointer value.
\end{enumerate}
\item In addition, the checking of function call arguments in
      Section~\ref{section:checking-function-call-arguments} is applied
      when the called function has bounds-safe interfaces for one or more parameters.
\end{itemize}

Assignments to variables with bounds-safe interfaces are an interesting
case.  The checking is done at the expression statement level or at
the bundled declaration level, if several statements are needed to update
an invariant bounds declaration. 

\subsection{Examples}

Here are some examples:
\begin{verbatim}
void f() 
{
    int a;
    // the type of &a will be int *.  This will be implicitly converted to
    // ptr<int>.
    ptr<int> pa : bounds(&a, &a + 1) = &a;
    int arr[5][5];
    // the type of arr will be int[5] *.  This will be implicitly converted to
    // ptr<int[5]> 
    ptr<int[5]> parr : bounds(arr, arr + 1) = arr;
    ...
}

void copy(array_ptr<int> dest : count(len), 
          array_ptr<int> src : count(len), int len)
{
    // dest, src will be converted to a void *
    // The checking of bounds information succeeds at compile time.
    // The runtime bounds checks that dest and src are in range are  
    // guaranteed to succeed
    memcpy(dest, src, len);
}
 
f(S s) 
{
     int len = s.len;
     array_ptr<char> sp : count(len) = s.arr;
     ...
     if (len > 0) {
        sp[0] = 'a';
     }
}
\end{verbatim}

The following example will fail at compile time. The bounds for sp will
be computed as \texttt{bounds(none)}, which clearly does not match
\texttt{count(sp, sp + 1)}.
\begin{verbatim}
char *random();

f() {
    array_ptr<char> sp : count(1) = random(); 
}
\end{verbatim}
