% !Tex root = checkedc.tex

\chapter{Pending work and open issues}
\label{chapter:open-issues}

This chapter discuss work that needs to be done and open issues.

\section{Pending work}

\begin{itemize}
\item Allow conditional bounds expressions.   While we allow conditional
expressions in the non-modifying expressions in a bounds expression, we
do not have a conditional form of bounds expressions.  This is useful for
specifying that an expression only has bounds if some condition is true.
This could be provided by adding a clause to bounds-exp that uses the
same syntax as C conditional expressions:
\begin{tabbing}
\var{bounds}\=\var{-exp:} \\
\>\texttt{\var{non-modifying-exp} ? \var{bounds-exp} : \var{bounds-exp}}
\end{tabbing}

We have to add descriptions of introduction and elimination
forms, as well as enhance the rules for checking the validity of bounds.
\item Allow bounds declarations to declare bounds for expressions.
This would allow us to easily describe the bounds when pointers are tagged.
We would describe the bounds for the untagged pointer.  A tagged pointer
could not be used to access memory.  It would have to be untagged first 
to have valid bounds.
\end{itemize}

\section{Language and library features to be addressed}

\begin{itemize}
\item
  Decide what to about null terminated arrays. Do we have special rules
  for them?
\item
  Old-style function declarations where argument list length or
  parameter/argument types could be mismatched at compile time, leading
  to undefined behavior.
\item
  Function pointers: the where clauses must become part of the signature
  of the pointer type.
\item
  Variable arguments
\item
  Pointer casts that produce incorrectly aligned pointers have undefined
  behavior, according to the C11 standard. This hole should be filled in
  for safe pointer types. For safe pointer types, we should specify
  either (1) dereferencing an incorrectly aligned pointer shall cause a
  runtime error or (2) the cast itself shall check any alignment
  requirements. For case 1, note that safe pointer arithmetic is already
  defined to preserve misalignment.
\end{itemize}

\section{Concrete syntax}

\subsection{Post-condition syntax}
The current syntax for describing post-conditions places a where clause
after the function parameter list declaration:

\begin{verbatim}
f( ...)
where cond1 ...
\end{verbatim}

This syntax might lead to confusion. We might want to adopt an alternate
syntax that makes this clearer. At the design discussion on 7/29/2015,
it was discovered that the group did not understand that the where
clause after the function parameter list applied to post-conditions.

Some suggestions are the keywords \texttt{on\_return} or \texttt{after}:

\begin{verbatim}
f(...)
where cond1 ...

f(...)
after cond1 ...
\end{verbatim}

\section{Discussion of optimizing bounds check and overflow}

We had the following discussion in Section~{section:bounds-checking-at-indirections}
that distracted from the
main point of the section. It's also confusing the overflow check for x
+ c is omitted. The point of the example below is that we can make code
efficient. That deserves a fuller discussion and should be buttressed by
empirical data.

Consider as an example, z = *(x+5); where x : bounds(x, x + c). The
compiler will produce code of the form

\begin{quote}
\begin{verbatim}
assert(x != null);
t1 = x + 5;
check x + 5 for overflow
assert(t1 != null && x <= t1 && t1 < x + c);
z = *t1;
\end{verbatim}
\end{quote}

This simplifies to:

\begin{quote}
\begin{verbatim}
assert(x != null);
t1 = x + 5;
check for overflow x + 5
assert(x <= t1 && t1 < x+c);
z = *t1;
\end{verbatim}
\end{quote}

The compiler can recognize that \texttt{x <= t1} is always true,
leading to:-

\begin{quote}
\begin{verbatim}
assert(x != null);
t1 = x + 5;
check for overflow of x + 5
assert(t1 < x + c);
z = *t1;
\end{verbatim}
\end{quote}