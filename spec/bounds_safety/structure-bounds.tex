% !Tex root = checkedc.tex

\chapter{Bounds declarations for structure types}
\label{chapter:structure-bounds}

This chapter extends reasoning about bounds to objects with structure
types by introducing bounds declarations for structure members.
Structure types may have members with \arrayptr\ types. Those
members must have \emph{member bounds declarations} associated with them in order for
the values stored there to be used to access memory.

The declarations of
structure members may include \keyword{where} clauses that declare member
bounds. The member bounds declarations may also be placed inline.
A structure declaration may also include \keyword{where} clauses at the same
level as member declarations.  Here are examples:

\begin{lstlisting}
struct S {
    array_ptr<int> data where data : count(num);
    int num;
};
\end{lstlisting}
or
\begin{lstlisting}
struct S {
    array_ptr<int> data : count(num);
    int num;
};
\end{lstlisting}
or
\begin{lstlisting}
struct S {
    array_ptr<int> data;
    int num;
    where data : count(num);
};
\end{lstlisting}

Member bounds declarations are program invariants that are assumed to be true
by default for objects of that type.
Making member bounds declarations be invariants provides a way to deal with issues
caused by aliasing. There can be pointers to data structures or members
of data structures. There may be multiple pointers to a single
structure object in memory. When there are multiple pointers,
the pointers are called aliases because they all name the same
memory location.  Aliasing makes it hard to reason about programs.

Consider the example:
\begin{lstlisting}
f(S *q, S *r, bool b)
{
   if (b) {
      q->arr = malloc(sizeof(int)*5);
      q->len = 5;
   }
   else {
      r->arr = malloc(sizeof(int)*5);
      r->len = 5;
   }
}
\end{lstlisting}

Even when b is true, the value \code{r->arr} may still be
changed by a call to f. This can happen when \code{q} and \code{r}
are the same value and are aliases for the same memory location.
Changing one named value (\code{q->arr}) can have the
effect of changing some other value with a distinct name
(\code{r->arr}). In general, it is difficult to know
whether an assignment through one pointer variable is affecting the
members of other pointer variables.

Member bounds declarations being program invariants for structure members allows
localized reasoning about the members. A programmer can assume that the
bounds declarations are true for members of objects of that type.   Initializers for
structure variables must establish the validity of the member bounds declarations and
updates to structure members of objects must preserve the member bounds
declarations invariants.  The updates may need to be enclosed in a 
\code{bundled} block.

We will check statically that programs maintain the validity of bounds
declarations for structure members.   
Section~\ref{section:checking-bounds-with-structures} generalizes
the rules in Chapter~\ref{chapter:checking-bounds} from variables
to lvalue expressions with {\em bounds invariants}.  The new
expressions covered include structure member access expressions, 
pointer dereference expressions, and array subscripting expressions.   

In the rest of this chapter, to simplify the description, assumptions
about address-taken variables similar to those in
Section~\ref{section:bounds-declarations} are made.
It is assumed that none of the variables or members of variables on the
left-hand side of bounds-declarations have their addresses taken. It is
assumed also that the values of variables or members of variables whose
addresses are taken are not used in bounds expressions.

\section{Declaring bounds for structure members}

Member bounds declarations have the form:
\begin{tabbing}
\var{member}\=\var{-bounds-decl:}\\
\> \var{member-path} \code{:} \var{member-bounds-exp} \\
\\
\var{member-path:}\\
\> \var{identifier} \\
\> \var{member-path} \code{.} \var{identifier}
\end{tabbing}

A member path is a sequence of one or more member names, separated by
the `\code{.}' operator. The sequence of members must be a valid sequence of
member accesses for the structure type. The common case of using a
member of the structure type is simply a member path of length 1.

Member bounds expressions are similar to the bounds expressions
described in Section~\ref{section:bounds-declarations}, 
except that members of the structure type are
used in place of variables in the non-modifying expressions. In
addition, pointer indirection and indirect member references are
excluded.

A structure member whose type is \arrayptr\ or a
checked array type may have at most one bounds declared for it. The
typing rules for member bounds declarations are similar to those for
variable bounds declarations. For bounds declarations of the form
\boundsdecl{\var{member-path}}{\boundscount{\var{e1}}}, the
\var{member-path} cannot have the type \arrayptrvoid\ and
the expression \var{e1} must have an integral type. For bounds declarations
of the form \boundsdecl{\var{member-path}}{\bounds{\var{e1}}{\var{e2}}},
the types of \var{e1} and \var{e2} must be pointers to the same type.
Typically \var{member-path} is also  a pointer to that type or an
array of that type.  However, \var{member-path} can be a pointer to
or an array of a different type.

A structure consists of a list of member declarations, each of which
consists of a type specifier followed by one or more structure member
declarators. Structure member declarators are changed to allow 
optional in-line specification of member bounds and \keyword{where}
clauses.

\begin{tabbing}
\var{struct}\=\var{-member-declarator:}\\
\> \var{declarator where-clause\textsubscript{opt}} \\
\> \var{declarator\textsubscript{opt}} \code{:}
   \var{constant-expression} \\
\> \var{declarator} \code{:} \var{member-bounds-exp}
\var{where-clause\textsubscript{opt}} \\
\\
The list of member declarations is extended to include \keyword{where}
clauses:\\
\\
\var{struct-member-declaration:}\\
\> \ldots{} \\
\> \var{where-clause}\textsubscript{opt}  \\
\\
The remaining syntax for specifying a structure remains unchanged: \\
\\
\var{struct-or-union-specifier:}\\
\> \var{struct-or-union identifier\textsubscript{opt}} \lstinline|{|
\var{struct-member-declaration-list} \lstinline|}| \\
\\
\var{struct-member-declaration-list:} \\
\> \var{struct-member-declaration} \\
\> \var{struct-member-declaration-list struct-member-declaration} \\
\\
\var{struct-member-declaration:} \\
\> \var{specifier-qualifier-list struct-member-declarator-list} \code{;} \\
\\
\var{struct-member-declarator-list:} \\
\> \var{struct-member-declarator} \\
\> \var{struct-declarator-list} \code{,} \var{struct-member-declarator} 
\end{tabbing}

A member bounds expression can use members and child members of the
structure being declared. Any member paths occurring in the member
bounds expressions must start with members of the structure type being
declared. Here is an example of the use of child members:

\begin{lstlisting}
struct A {
   array_ptr<int> data;
};

struct N {
    int num;
};

struct S {
   A a
   where count(a.data) == n.num;
   N n;
};
\end{lstlisting}

Allowing member bounds to use nested members of members complicates
explaining concepts. Sometimes concepts will be explained using member
bounds that use only immediate members and then generalized to handle
nested members.

\section{Bounds-safe interfaces}
\label{section:structure-bounds-safe-interfaces}

Just as existing functions can have bounds-safe interfaces declared for
them, existing structure types can have bounds-safe interfaces declared
for them. This allows checked code to use those data structures and for
the uses to be checked. Existing unchecked code is unchanged.
To create a bound-safe interface for a structure type, a programmer
declares member bounds or interface types for structure members with
unchecked pointer types.

Here is a member bounds declaration for a structure that is a counted buffer
of characters:

\begin{lstlisting}
struct CountedBuffer {
     char *arr : count(len);
     int len;
}
\end{lstlisting}

Here are bounds-safe interface types for members of a structure for binary
tree nodes. The structure contains pointers to two other nodes.  In
checked code, pointer arithmetic on those pointers is not allowed.

\begin{lstlisting}
struct BinaryNode {
    int data;
    BinaryNode *left : itype(ptr<BinaryNode>);
    BinaryNode *right : itype(ptr<BinaryNode>);
}
\end{lstlisting}

If bounds information is declared for one member of a structure with an
unchecked pointer type, it must be declared for all other members of the
structure with unchecked pointer types.

It is important to understand that the \emph{semantics of unchecked
pointers in unchecked contexts does not change even when bounds are declared 
for the pointers}. The declared bounds are used only by checked code that uses the
data structure, when storing checked pointers into the data structure, and when converting
unchecked pointers read from the data structure to checked pointers.  Code in unchecked
contexts that uses only unchecked pointer types is compiled as though the bounds-safe
interface has been stripped from the source code.

\section{Inferring bounds expressions for member access expressions}

In this section, we informally explain how to infer bounds expressions for
member access expressions for members that have bounds declarations.

Given an expression \var{e} \var{op} \var{m}, where 
\begin{itemize}
\item \var{op} is either \code{.} or \code{->}, and 
\item \var{m} is a member that has a member bounds declaration  \var{d}
\end{itemize}
the bounds declaration for the expression is created by taking \var{d} and replacing
members \var{d} that have been used in place of variables with member access
expression.  For each use of a member \var{p}, replace each occurrence of \var{p}
with \var{e} \var{op} \var{p}.  If  \var{e} has side-effects,
\var{e} is replaced with a temporary that will contain the lvalue (or value) to
which \var{e} evaluates.

Here are examples of bounds expressions for member access expressions.
Given
\begin{lstlisting}
struct Buffer {
   array_ptr<int> data : count(len);
   int len;
};

void f(struct Buffer b) {
  ...   b.data[0] ...
}
\end{lstlisting}
the bounds for \code{b.data} are \code{count(b.len)}.   The expanded bounds are
\code{bounds(b.data, b.data + b.len)}.   The bounds check for \code{b.data[0]} will 
check that \code{b.data + 0 <= b.data} and \code{b.data + 0 < b.data + b.len}.
If \code{len} is \code{0}, the bounds check will fail.

Given
\begin{lstlisting}
void g(ptr<struct Buffer> b) {
   ... b->data[0] ...
}
\end{lstlisting}
the bounds for \code{b->data} are \code{count(b->len)}.  The expanded bounds are
\code{bounds(b->data, b->data + b->len)}.
In C, the expression \code{e->m} is equivalent to \code{(*e).m}.   Given
\begin{lstlisting}
void g(ptr<struct Buffer> b) {
   ... (*b).data[0] ...
}
\end{lstlisting}
the bounds for \code{(*b).data)} are \code{count((*b).len}.  The expanded bounds are
\code{bounds((*b).data, (*b).data + (*b).len}.
The following example shows the inference of a bounds expression  when the base expression of
a member access has a side effect:
\begin{lstlisting}
void ptr<struct Buffer> get(int i);

int h(int num, int index) {
  return get(num)->data[index];
}
\end{lstlisting}
A new temporary \var{t1} is introduced by the compiler to hold the result of
\code{get(num)} at runtime.   
The bounds for \code{get(num)->data} are \code{count(}\var{t1}\code{->len)}.
The expanded bounds are 
\code{bounds(}\var{t1}\code{->data,}\var{t1}\code{->data +}  \var{t1}\code{->len)}.

\section{Extending bounds declaration checking}
\label{section:checking-bounds-with-structures}

This section extends the checking in Chapter~\ref{chapter:tracking-bounds} from
variables to the remaing forms of lvalue expressions: structure member accesses, pointer
dereferences, and subscript expressions.  These have to be handled together because
they interact.  Structure member accesses may use other lvalue expressions as 
base expressions, and the other expressions may modify entire structures.

It is important to understand that structure bounds declarations are program-wide invariants.
An assignment to a structure member of a specific object implies that an invariant about
that specific object must hold, when the member is involved in a bounds declaration.
To be concrete, if the bounds declaration involves multiple members, we must check
that all the members have been updated accordingly.  

When an assignment is made to a specific member, the object may enter a state where the
program-wide invariant temporarily does not hold.  The invariant must hold by the end of evaluating 
a full expression or a bundled block.

The presence of aliasing makes this challenging to reason about.  Aliasing is when two pointers
(or lvalues) point to overlapping memory.   Changing memory via one pointer may change the
result of accessing memory via the other pointer.  We largely side-stepped aliasing issues in the
treatment of variables by disallowing taking the address of variables.  With pointer dereferences,
we cannot avoid reasoning about aliasing.

The extended checking works as follows:
\begin{itemize}
\item An assignment to a structure member implies that an invariant about a specific
object must hold.  In Chapter~\ref{chapter:tracking-bounds}, we were able to use
declarations of variables to track what invariants need to be checked.    These were
described as  the {\em declared context}.  In this checking, we add an {\em implied context}.
which tracks new invariants created by assignments to members of objects.  The implied
context must be passed through the checking routines.   The implied context is a map
from non-modifying lvalue expressions to the bounds expression that must be true at the
end of evaluating the expression.
\item The sets of pending variables become {\em pending lvalue expressions}.   These
describe lvalues that may or may not have been updated yet.   It is undefined for an expression
to read memory and write to the same memory in an unordered fashion, as well as for an 
expression to have multiple writes to the same memory that are unordered.  
\item We introduce a function {\em IsDisjoint} that determines when two lvalue expressions
do not alias.  It return true when two lvalue expressions must denote disjoint ranges of memory,
false otherwise.   This is used to detect when there are conflicting reads/write and writes/writes
involving lvalue expressions.

This function is pessimistic, in that it assumes aliasing unless aliasing can be disproven.  Currently, 
we have no notation for describing the lack of aliasing in data structures or during function calls.   
{\em IsNotAliased} could be made less pessimistic with this information.

\item At a function call, we assume that the function call may read or write any memory accessible
to the function being called.  For local variables whose addresses are not taken, we can assume that 
function call does not modify them. For data structures, we assume that a function may read or write them.
This implies that structure member bounds declarations must hold before function calls.  That in
turn implies that unordered calls and assignments via pointers to structure members involved in bounds declarations will not be allowed in the same expression.

Note that C places a sequence point after the arguments and function target for a call have been 
evaluated and before the call.  So an assignment that is part of argument expression would be allowed,
unless there were multiple unsequenced calls within the entire expression,  C also states that
function evaluations are not interleaved, even when the calls themselves are unordered.  We do
not have to wory about unordered function calls conflicting with each other with respect to preserving
structure member bounds declarations.

\item Because the checking works in terms of lvalue expressions, we must make sure that we 
do not lose track of lvalues during the checking.  When a variable that is used in computing an
lvalue expression changes, for example, we must make sure that we can compute the original
value of the expression.  If we cannot, we made to signal an error.  In assignment through a pointer
may invalidate an lvalue expression that reads a pointer, if the two pointers are potentially alised.
In this case, we will need to signal an error.
\end{itemize}

In Chapter~\ref{chapter:checking-bounds}, contexts map pointer variables to their bounds.
Contexts are extended to map structure variables to descriptions of bounds for their
members.  The bounds for members of a variable will be described using a set of pairs,
where the first element of each pair is a member path whose type is \arrayptr\
and the second element of each pair is a bounds expression.  The bounds expression may use 
variable member paths in addition to variables.

In Section~\ref{section:inferring-expression-bounds}, the inference of bounds for an
expression determines the bounds expression that applies to the value of the
expression.  For structure-typed expressions, inference is generalized to determine
the bounds expressions that apply to the \arrayptr\ members of the value 
of the expression.  This information is represented using the same
representation used for contexts: a set of pairs, where the first element 
is a member path whose type is \arrayptr\ and the second element is a 
bounds expression.  Given this representation, it is easy to define
the rules for inferring bounds for member accesses: a member access prunes the
set of pairs and shortens the member paths.

In Section~\ref{section:checking-complex-expressions}, checking of assignment
expressions updates contexts.  The contexts are then used to check that expression
statements imply declared bounds.  They are also used to check expressions nested
within an expression that contain assignment expressions. 
Given the representation of contexts, the rules for updating contexts
are extended to update contexts pointwise for structure variable assignments and member 
assignments.  For a structure variable assignment, the entire set of pairs for a
variable is updated.  For an assignment to a member of a  structure variable,
only the set of entries  associated with that member are updated.  Both forms of assignment
invalidate bounds expressions that use variable member paths that are changed by the
assignment.

An expression statement is checked by determining the updated context for the
expression statement, determining the expected context for bounds after 
the statement, and then checking that the updated context implies the
validity of the bounds in the expected context (Section ~\ref{section:checking-full-expressions}).
For each variable in the expected context, it is checked that the bounds expression in
the updated context implies the expected bounds expression.  This is easily 
extended to a structure variable by checking for each member path for 
the variable that the bounds expression in the updated context implies
the expected bounds expression.

\subsection{Determining contexts}

The context for every statement can be determined by using dataflow analyses extended
pointwise to structure variables.  Each structure variable is expanded into the set
of variable member paths that represent all \arrayptr-typed variable member paths beginning
with the variable.  First, an iterative forward dataflow analysis is done to determine the
member bounds state at every point in a function, following the rules in
Section~\ref{section:member-bounds-state-extent}.  The analysis works on the set of variable
member paths.   It computes for each variable member path whether the member bounds are valid 
at each program point.  It is a compile-time error if the analysis determines that the state of
member bounds is inconsistent along different paths.

Second, a generalized version of the extent dataflow analysis of Section~\ref{section:computing-extent}
is done.  Each structure variable is expanded into the set of variable
member paths that represent all \arrayptr-typed variable member paths begining with 
the variable.  The analysis assigns one lattice value to each of the variable member path for
each program point in the function where the variable is in scope.

The context for a statement is computed using the results of the dataflow analyses.
For each structure variable in scope for the statement, the set of \arrayptr-typed variable member paths 
beginning at the variable is determined.  The set is mapped to a set of pairs as follows:
\begin{itemize}
\item For the first element, the structure variable is removed from the beginning of the
path to create a member path.
\item For the second element, the extent dataflow analysis is consulted for the \arrayptr\ member path.
   If the bounds expression is not \boundsunknown, it is used.   If it is \boundsunknown, the result
   of the dataflow analysis for the member bounds state is examined. If the member bounds
   state is valid, the member bounds is used.  It is transformed to use variable member
   bounds by prefixing the member paths that occur in it with the structure variable.
   Otherwise, \boundsunknown\ is used.
\end{itemize}

\subsection{Inferring bounds for expressions without assignments}

This section describes extensions to Section~\ref{section:inferring-expression-bounds} for
determining bounds.   The notation \boundsinfer{\var{e}}{\var{s}} is overloaded for expressions
with structure types to mean that \var{e} has a set of member paths with individual bounds expressions.
\begin{itemize}
\item Variables: If \var{x} has a structure type, the context is consulted for \var{x} for
the set \var{s} of pairs of member paths and bounds expressions.  \boundsinfer{\var{x}}{\var{s}}.
\item Member access: Given an expression \var{e}\code{.}\var{m}, where \var{m} is 
a member name and \boundsinfer{\var{e}}{\var{s}},
\begin{itemize}
\item If \var{e}\code{.}\var{m} has a structure type, then
\begin{itemize}
\item The set $\var{s}^{\prime}$ is defined as follows.  For each pair 
      \texttt{(\var{mp}, \var{b})} in \var{s}, if \var{mp} has the form 
      \var{m}\code{.}\var{rp}, then \texttt{(\var{rp}, \var{b})} is
      included in $\var{s}^\prime$.
\item  Given $\var{s}^\prime$, \boundsinfer{\var{e}\code{.}\var{m}}{$\var{s}^\prime$}.
\end{itemize}
\item Otherwise,
\begin{itemize}
\item If $\var{s} = \texttt{\{(\var{m}, \var{b})\}}$, then \boundsinfer{\var{e}\code{.}\var{m}}{b}
\item Otherwise, \boundsinfer{\var{e}\code{.}\var{m}}{\boundsunknown}
\end{itemize}
\end{itemize}
\item Function calls: {\em To be filled in}
\end{itemize}

\subsection{Assignment expressions}

{\em To be filled in.}

\section{Compatibility of structure types with bounds declarations}

The C Standard defines compatibility of two structure types declared in
separate translation units \cite[Section 6.2.7]{ISO2011}.  This definition
is extended to include member bounds declarations and member bounds-safe
interfaces.  If the structure types are completed in both translation
units, for each pair of corresponding members,
\begin{itemize}
\item If the members have unchecked pointer type,
\begin{itemize}
\item If the members both have bounds-safe interfaces, the bounds-safe
interfaces must either both be bounds expressions or both be interface
types. If both have bounds expressions, the bounds expressions must be
syntactically identical after being placed into a canonical form.
If both have interface types, the interface types must be compatible.
\item Otherwise,  one member must have a bounds-safe interface and the
other member must omit a bounds-safe interface, or both members must omit
bounds-safe interfaces.
\end{itemize}
\item Otherwise, both members must have member bounds declarations or both
members must not have member bounds declarations.  If both members have
member bounds declarations, the bounds expressions must be syntactically
identical after being placed into canonical form.
\end{itemize}
