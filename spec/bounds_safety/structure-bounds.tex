% !Tex root = checkedc.tex

\chapter{Bounds declarations for structure types}
\label{chapter:structure-bounds}

This chapter extends reasoning about bounds to objects with structure
types by introducing bounds declarations for structure members.
Structure types may have members with \arrayptr\ types. Those
members must have \emph{member bounds declarations} associated with them in order for
the values stored there to be used to access memory.

The declarations of
structure members may include \keyword{where} clauses that declare member
bounds. The member bounds declarations may also be placed inline.
A structure declaration may also include \keyword{where} clauses at the same
level as member declarations.  Here are examples:

\begin{lstlisting}
struct S {
    array_ptr<int> data where data : count(num);
    int num;
};
\end{lstlisting}
or
\begin{lstlisting}
struct S {
    array_ptr<int> data : count(num);
    int num;
};
\end{lstlisting}
or
\begin{lstlisting}
struct S {
    array_ptr<int> data;
    int num;
    where data : count(num);
};
\end{lstlisting}

Member bounds declarations are program invariants that are assumed to be true
by default for objects of that type.
Making member bounds declarations be invariants provides a way to deal with issues
caused by aliasing. There can be pointers to data structures or members
of data structures. There may be multiple pointers to a single
structure object in memory. When there are multiple pointers,
the pointers are called aliases because they all name the same
memory location.  Aliasing makes it hard to reason about programs.

Consider the example:
\begin{lstlisting}
f(S *q, S *r, bool b)
{
   if (b) {
      q->arr = malloc(sizeof(int)*5);
      q->len = 5;
   }
   else {
      r->arr = malloc(sizeof(int)*5);
      r->len = 5;
   }
}
\end{lstlisting}

Even when b is true, the value \code{r->arr} may still be
changed by a call to f. This can happen when \code{q} and \code{r}
are the same value and are aliases for the same memory location.
Changing one named value (\code{q->arr}) can have the
effect of changing some other value with a distinct name
(\code{r->arr}). In general, it is difficult to know
whether an assignment through one pointer variable is affecting the
members of other pointer variables.

Member bounds declarations being program invariants for structure members allows
localized reasoning about the members. A programmer can assume that the
bounds declarations are true for members of objects of that type.   Initializers for
structure variables must establish the validity of the member bounds declarations and
updates to structure members of objects must preserve the member bounds
declarations invariants.  The updates may need to be enclosed in a 
\code{bundled} block.

We will check statically that programs maintain the validity of bounds
declarations for structure members.   
Section~\ref{section:checking-bounds-with-structures} generalizes
the rules in Chapter~\ref{chapter:checking-bounds} from variables
to lvalue expressions with {\em bounds invariants}.  The new
expressions covered include structure member access expressions, 
pointer dereference expressions, and array subscripting expressions.   

In the rest of this chapter, to simplify the description, assumptions
about address-taken variables similar to those in
Section~\ref{section:bounds-declarations} are made.
It is assumed that none of the variables or members of variables on the
left-hand side of bounds-declarations have their addresses taken. It is
assumed also that the values of variables or members of variables whose
addresses are taken are not used in bounds expressions.

\section{Declaring bounds for structure members}

Member bounds declarations have the form:
\begin{tabbing}
\var{member}\=\var{-bounds-decl:}\\
\> \var{member-path} \code{:} \var{member-bounds-exp} \\
\\
\var{member-path:}\\
\> \var{identifier} \\
\> \var{member-path} \code{.} \var{identifier}
\end{tabbing}

A member path is a sequence of one or more member names, separated by
the `\code{.}' operator. The sequence of members must be a valid sequence of
member accesses for the structure type. The common case of using a
member of the structure type is simply a member path of length 1.

Member bounds expressions are similar to the bounds expressions
described in Section~\ref{section:bounds-declarations}, 
except that members of the structure type are
used in place of variables in the non-modifying expressions. In
addition, pointer indirection and indirect member references are
excluded.

A structure member whose type is \arrayptr\ or a
checked array type may have at most one bounds declared for it. The
typing rules for member bounds declarations are similar to those for
variable bounds declarations. For bounds declarations of the form
\boundsdecl{\var{member-path}}{\boundscount{\var{e1}}}, the
\var{member-path} cannot have the type \arrayptrvoid\ and
the expression \var{e1} must have an integral type. For bounds declarations
of the form \boundsdecl{\var{member-path}}{\bounds{\var{e1}}{\var{e2}}},
the types of \var{e1} and \var{e2} must be pointers to the same type.
Typically \var{member-path} is also  a pointer to that type or an
array of that type.  However, \var{member-path} can be a pointer to
or an array of a different type.

A structure consists of a list of member declarations, each of which
consists of a type specifier followed by one or more structure member
declarators. Structure member declarators are changed to allow 
optional in-line specification of member bounds and \keyword{where}
clauses.

\begin{tabbing}
\var{struct}\=\var{-member-declarator:}\\
\> \var{declarator where-clause\textsubscript{opt}} \\
\> \var{declarator\textsubscript{opt}} \code{:}
   \var{constant-expression} \\
\> \var{declarator} \code{:} \var{member-bounds-exp}
\var{where-clause\textsubscript{opt}} \\
\\
The list of member declarations is extended to include \keyword{where}
clauses:\\
\\
\var{struct-member-declaration:}\\
\> \ldots{} \\
\> \var{where-clause}\textsubscript{opt}  \\
\\
The remaining syntax for specifying a structure remains unchanged: \\
\\
\var{struct-or-union-specifier:}\\
\> \var{struct-or-union identifier\textsubscript{opt}} \lstinline|{|
\var{struct-member-declaration-list} \lstinline|}| \\
\\
\var{struct-member-declaration-list:} \\
\> \var{struct-member-declaration} \\
\> \var{struct-member-declaration-list struct-member-declaration} \\
\\
\var{struct-member-declaration:} \\
\> \var{specifier-qualifier-list struct-member-declarator-list} \code{;} \\
\\
\var{struct-member-declarator-list:} \\
\> \var{struct-member-declarator} \\
\> \var{struct-declarator-list} \code{,} \var{struct-member-declarator} 
\end{tabbing}

A member bounds expression can use members and child members of the
structure being declared. Any member paths occurring in the member
bounds expressions must start with members of the structure type being
declared. Here is an example of the use of child members:

\begin{lstlisting}
struct A {
   array_ptr<int> data;
};

struct N {
    int num;
};

struct S {
   A a
   where count(a.data) == n.num;
   N n;
};
\end{lstlisting}

Allowing member bounds to use nested members of members complicates
explaining concepts. Sometimes concepts will be explained using member
bounds that use only immediate members and then generalized to handle
nested members.

\section{Bounds-safe interfaces}
\label{section:structure-bounds-safe-interfaces}

Just as existing functions can have bounds-safe interfaces declared for
them, existing structure types can have bounds-safe interfaces declared
for them. This allows checked code to use those data structures and for
the uses to be checked. Existing unchecked code is unchanged.
To create a bound-safe interface for a structure type, a programmer
declares member bounds or interface types for structure members with
unchecked pointer types.

Here is a member bounds declaration for a structure that is a counted buffer
of characters:

\begin{lstlisting}
struct CountedBuffer {
     char *arr : count(len);
     int len;
}
\end{lstlisting}

Here are bounds-safe interface types for members of a structure for binary
tree nodes. The structure contains pointers to two other nodes.  In
checked code, pointer arithmetic on those pointers is not allowed.

\begin{lstlisting}
struct BinaryNode {
    int data;
    BinaryNode *left : itype(ptr<BinaryNode>);
    BinaryNode *right : itype(ptr<BinaryNode>);
}
\end{lstlisting}

If bounds information is declared for one member of a structure with an
unchecked pointer type, it must be declared for all other members of the
structure with unchecked pointer types.

It is important to understand that the \emph{semantics of unchecked
pointers in unchecked contexts does not change even when bounds are declared 
for the pointers}. The declared bounds are used only by checked code that uses the
data structure, when storing checked pointers into the data structure, and when converting
unchecked pointers read from the data structure to checked pointers.  Code in unchecked
contexts that uses only unchecked pointer types is compiled as though the bounds-safe
interface has been stripped from the source code.

\section{Inferring bounds expressions for member access expressions}

In this section, we informally explain how to infer bounds expressions for
member access expressions for members that have bounds declarations.

Given an expression \var{e} \var{op} \var{m}, where 
\begin{itemize}
\item \var{op} is either \code{.} or \code{->}, and 
\item \var{m} is a member that has a member bounds declaration  \var{d}
\end{itemize}
the bounds declaration for the expression is created by taking \var{d} and replacing
members \var{d} that have been used in place of variables with member access
expression.  For each use of a member \var{p}, replace each occurrence of \var{p}
with \var{e} \var{op} \var{p}.  If  \var{e} has side-effects,
\var{e} is replaced with a temporary that will contain the lvalue (or value) to
which \var{e} evaluates.

Here are examples of bounds expressions for member access expressions.
Given
\begin{lstlisting}
struct Buffer {
   array_ptr<int> data : count(len);
   int len;
};

void f(struct Buffer b) {
  ...   b.data[0] ...
}
\end{lstlisting}
the bounds for \code{b.data} are \code{count(b.len)}.   The expanded bounds are
\code{bounds(b.data, b.data + b.len)}.   The bounds check for \code{b.data[0]} will 
check that \code{b.data + 0 <= b.data} and \code{b.data + 0 < b.data + b.len}.
If \code{len} is \code{0}, the bounds check will fail.

Given
\begin{lstlisting}
void g(ptr<struct Buffer> b) {
   ... b->data[0] ...
}
\end{lstlisting}
the bounds for \code{b->data} are \code{count(b->len)}.  The expanded bounds are
\code{bounds(b->data, b->data + b->len)}.
In C, the expression \code{e->m} is equivalent to \code{(*e).m}.   Given
\begin{lstlisting}
void g(ptr<struct Buffer> b) {
   ... (*b).data[0] ...
}
\end{lstlisting}
the bounds for \code{(*b).data)} are \code{count((*b).len}.  The expanded bounds are
\code{bounds((*b).data, (*b).data + (*b).len}.
The following example shows the inference of a bounds expression  when the base expression of
a member access has a side effect:
\begin{lstlisting}
void ptr<struct Buffer> get(int i);

int h(int num, int index) {
  return get(num)->data[index];
}
\end{lstlisting}
A new temporary \var{t1} is introduced by the compiler to hold the result of
\code{get(num)} at runtime.   
The bounds for \code{get(num)->data} are \code{count(}\var{t1}\code{->len)}.
The expanded bounds are 
\code{bounds(}\var{t1}\code{->data,}\var{t1}\code{->data +}  \var{t1}\code{->len)}.

\section{Extending bounds declaration checking}
\label{section:checking-bounds-with-structures}

This section extends the checking in Chapter~\ref{chapter:tracking-bounds} from
variables to the remaing forms of lvalue expressions: structure member accesses, pointer
dereferences, and subscript expressions.  These have to be handled together because
they interact.  Structure member accesses may use other lvalue expressions as 
base expressions, and the other expressions may modify entire structures.

It is important to understand that structure bounds declarations are program-wide invariants.
An assignment to a structure member of a specific object implies that an invariant about
that specific object must hold, when the member is involved in a bounds declaration.
If the bounds declaration involves multiple members, we must check that all the members have
been updated accordingly.  

When an assignment is made to a specific member, the object may enter a state where the
program-wide invariant temporarily does not hold.  The invariant must hold by the end of evaluating 
a full expression or a bundled scope.

The presence of aliasing makes this challenging to reason about.  Aliasing is when two pointers
(or lvalues) point to overlapping memory.   Changing memory via one pointer may change the
result of accessing memory via the other pointer.  We largely side-stepped aliasing issues in the
treatment of variables by disallowing taking the address of variables.  With pointer dereferences,
we must reason about aliasing.

Checking of bounds declarations only enforces that member bounds invariants hold after member
assignments or structure assignments.  For example, if \code{struct S} has a member \code{m}
with a bound declaration, checking of bounds declarations will enforce that bounds invariants hold 
for assignments  of the form \code{e.m = ...} or \code{e->m = ...}, where e is some expression.

In code that is entirely checked, this is enough to enforce that member bounds invariants hold.  
Checked C disallows taking the address of members involved in bounds declarations.
In checked scopes, it disallows structure pointer casts that could allow the address of
a member to be computed.   The bounds checking also does not allow a programmer
to take the address of a member and construct a pointer that can be used to
access the memory of another member.

However, programs will be comprised of code that is also unchecked or that has
\code{bounds\_only} scopes (which allow pointer casts).   Programmers can create pointers
to members by casting to other pointer types and using pointer arithmetic.
If, at runtime, a program does a store via such a pointer to a member of an object
with a bounds declaration, the programmer is responsible for ensuring that the bounds declaration
invariant remains true.  Checking of bounds declaration will not enforce that member bounds invariants hold after 
those assignments.  
Specifically, the programmer must ensure that after the assignment, 
the bounds declaration invariant holds for the object before any member involved in the
 bounds declaration is read.
An example  \lstinline|ptr<int> p = ... ; *p = ...|,
where \code{p} points to struct member with a bounds declaration, it is the programmer
responsibility to ensure that the bounds invariant is true after \code{*p}.

The extended checking works as follows:
\begin{itemize}
\item An assignment to a structure member implies that an invariant about a specific
object must hold.  In Chapter~\ref{chapter:tracking-bounds}, we were able to use
declarations of variables to track what invariants need to be checked.    These were
described as  the {\em declared context}.  In this checking, we add an {\em implied context}.
which tracks new invariants created by assignments to members of objects.  The implied
context must be passed through the checking routines.   The implied context is a map
from non-modifying lvalue expressions to the bounds expressions that must be true at the
end of evaluating the expression.
\item The sets of pending variables become {\em pending lvalue expressions}.   These
describe lvalues that may or may not have been updated yet.   It is undefined for an expression
to read memory and write to the same memory in an unordered fashion, as well as for an 
expression to have multiple writes to the same memory that are unordered.  
\item We introduce functions{\em IsDisjoint} and {\em IsDisjointLValue} that determine when 
two pointer-typed expressions or two lvalue expressions do not alias. IsDisjoint returns
true when two  pointers must point to disjoint accessible ranges of memory  or two lvalue
expressions must denote disjoint ranges of memory. Otherwise it return false. This is used
to detect when there are  conflicting reads/write and writes/writes involving lvalue expressions.

These functions are pessimistic: they assume aliasing except in a few cases.  Currently, 
Checked C has no notation for describing the lack of aliasing in data structures or during
function calls. The functions could be made less pessimistic with this information.

\item Because the checking works in terms of lvalue expressions, we must make sure that we 
do not lose track of lvalues during the checking.  When a variable that is used in computing an
lvalue expression changes, for example, we must make sure that we can compute the original
value of the expression.  If we cannot, we made to signal an error.  In assignment through a pointer
may invalidate an lvalue expression that reads a pointer, if the two pointers are potentially alised.
In this case, we will need to signal an error.
\end{itemize}

\subsection{Aliasing assumptions and implications}

Two pointers alias if some memory accessible via one of the pointers is accessible via
the other pointer too.  Similarly, two lvalue expressions alias if some memory accessible via
one lvalue expression is also accessible via the other lvalue expression.
For C, we  make conservative assumptions about
aliasing of pointers and lvalues during checking of bounds declarations.  
Any unchecked pointer can be cast to another unchecked
pointer type.  Even in checked code, we take great care because unchecked code
may create unexpected aliasing.  

To check anything about bounds declarations involving pointer dereferences, we must make some
assumptions.  In code that is entirely checked, these assumptions will always be met.  However,
unchecked code might break these assumptions via casts and pointer arithmetic.   Here are our
assumptions during checking of bounds declarations:
\begin{itemize}
\item Bounds declarations are not circular: if the upper and lower bounds expressions of a
bounds declaration access lvalues, the lvalues are not within the memory range given
by the bounds. This code is not allowed:
\begin{lstlisting}
array_ptr<int> p : bounds(p, p + 1) = NULL;
p = dynamic_bounds_cast<ptr<int>>(&p);
\end{lstlisting}
Note that the code will be rejected because it takes the address of a variable used in bounds.
\item Accesses via different members of the same struct type do not overlap, even
when the base lvalues may overlap.  For example, given
\begin{lstlisting}
struct S {
  int len1;
  int len2;
  array_ptr<int> buf : count(len1 + len2);

}

void copy(ptr<struct S> dest, ptr<struct S> src) {
  bundled {
    (*dest).len1  = (*src).len1
    (*dest).len2 = (*src).len2;
    (*dest).buf = (*src).buf;
  }
}
\end{lstlisting}
The lvalues \code{*dest} and \code{*src} may denote the same object (this happens when the
same pointer is passed for both arguments). We assume that the lvalue \code{dest->len1}
does not overlap with the lvalue \code{src->len2} or \code{src->buf}.
\item We assume that pointers to distinct struct types are not aliases, unless one
struct type is a structural prefix of the other struct type or a structural prefix
of a member of the struct type.
The prefix is determined by enumerating a list of leaf members
and comparing their types structurally too.  For example, signedness
for integer types is ignored.
Similiarly, we assume that two lvalues that denote distinct struct types do not overlap,
unless one struct type is a structural prefix of the other struct type or a structural prefix of
a member of the other struct type.
  
For example, in the following code,
\code{dest} and \code{src} are assumed to not overlap because \code{S} and \code{T}
are distinct structure types and each is not a prefix of the other.
\begin{lstlisting}
struct T {
  array_ptr<int> buf : count(len);
  int len1;
  int len2;
}

void copy(ptr<struct S> dest, ptr<struct T> src) {
  bundled {
    (*dest).len1 = (*src).len1;
    (*dest).len2 = (*src).len2;
    (*dest).buf = (*src).buf;
  }
}
\end{lstlisting}
Similarly 

\item At a function call, we assume that the function call may read or write any memory accessible
to the function being called.  For local variables whose addresses are not taken, we can assume that 
the function call does not modify them. For data structures, we assume that a function may read or 
write them.  This implies that structure member bounds declarations must hold before function calls.
That in turn implies that unordered calls and assignments via pointers to structure members involved
in bounds declarations will not be allowed in the same expression.

Note that the C Standard places a sequence point after the arguments and function target for a call have been 
evaluated and before the call.  So an assignment to a structure member that is part of an argument 
expression would be allowed, unless there were multiple unsequenced calls within the entire 
The C Standard also states that
function evaluations are not interleaved, even when the calls themselves are unordered.  We do
not have to wory about unordered function calls conflicting with each other with respect to preserving
structure member bounds declarations.
\end{itemize}

These assumptions have another implication: assignments via pointers to primitive types may potentially
conflict with assignments or reads via pointers to structure members.  An unordered
write to a primitive type via a pointer will not be allowed in the same expression as a 
structure member assignment.  This limitation is intentional: it allows programmers to write
low-level code that must maintain/restore bounds invariants without bounds declaration
checking making incorrect assumptions that members of structures have not changed.

\subsection{Generalizing checking}

We generalize the checking from Chapter~\ref{chapter:checking-bounds} to cover checking
assignments to lvalue expressions.  First, some preliminaries.

Contexts are now maps from lvalue expressions with checked pointer or integer types
to bounds expressions.  We use the canonicalization routines from Chapter~\ref{chapter:checking-bounds}
to check of two lvalue expressions in the domain of the context are equivalent.  If
they are, we pick one of them as the canonical lvalue expression, and use it in place
of the others when operating on the contexts.  We require that lvalue expressions
in the domain of a context do not overlap according to the aliasing rules. If we
reach a situation where two lvalue expressions are not disjoint, it is an error
at checking time.

We use the following notation:
\begin{enumerate}
\item Given a context $C$, $C[e]$ returns the bounds for non-modifying lvalue expression $e$ in $C$.
\item $C[e \mapsto B]$ produces a new context that is identical to $C$,
except that lvalue expression  $e$ is mapped to $B$.
\item $e \in dom(C)$ means $e$ has an entry in $C$ ($e$ is in the domain of $C$).
\item $EQ - S$ takes sets of equivalent expressions $EQ$  and a set of lvalue expressions
$S$.  It produces new sets by removing any expressions that use the value 
of lvalue expressions in $S$.
\end{enumerate}

In Chapter~\ref{chapter:checking-bounds}, we had a notion of a declared context.  This
was the context that we wanted to prove was valid at the end of evaluating an expression.
Checking would compute a context $C$ and then show that it implied the declared context. 
The declared context was constructed from bounds declarations for variables.  With assignments to 
structure members, the declared context becomes a set of bounds invariants that we must
establish are true at the end of an expression.  An assignment to a structure member with
a bounds declaration or used in ab ounds in a bounds declaration adds a bound
invariant to establish.  We will use the variable $BI$ to for bound invariants
to prove.  This will be passed in as an argument to the checking functions and
returned as a value.

In Chapter~\ref{chapter:checking-bounds}, we introduced the notion of $Pending$ sets.
These sets were computed and then pass as arguments to recursive calls to $Check$
and $CheckLValue$.  Unfortunately, that approach becomes complex for lvalue expressions
because the lvalue expressions may use lvalues that are side-effected by the expressions.
The $Pending$ set computations would have to make adjustments for side-effects.  That
is confusing because the $Check$ and $CheckLValue$ expressions already make adjustments
for side-effects.

Instead of computing $Pending$ sets, we compute more direct information that can be
used to implement the same checks that were done using the $Pending$ sets.  We
modify $Check$ and $CheckLValue$ to compute $Read$ and $Write$ sets for each
subexpression.  We then make sure that there are not read/write or write/write
conflicts for subexpressions that do not have a defined order of evaluation with
respect to reach other.

The function $Check(e, C, EQ, Form, FB)$ takes as inputs:
\begin{enumerate}
\item An expression $e$ that evaluates to a value.
\item A context $C$.
\item Sets of equivalent expressions $EQ$.
\item Whether $e$ is special instruction form.  This can have 3 values: $No$, $PostIncDec$,
and $Compound$.
\item An optional bounds $FB$ for the first operand of $e$.  
This is used when checking compound assignments and pre/post-increment expressions.  These are
expanded to the form $e1~=~e1~op~e2$ where $e1$ is only processed once. 
\end{enumerate}

$Check$ returns:
\begin{enumerate}
\item A bounds expression $B$ for the values at runtime to which $e$ evaluates.
\item An updated context $\mathit{UC}$.
\item Updated sets of equivalent expressions $UEQ$.
\item A set of equivalent expressions $G$ that will produce the same value as $e$. 
\item A set of non-modifying lvalue expressions $R$ that may be read during evaluation of $e$.
\item A set of non-modifying lvalue expressions $W$ that may be written during evaluation of $e$
\item It may also report an error.
\end{enumerate}
The results produced by $Check$ are valid in the program state
{\em after} the assignments in $e$ have been completed.  In particular,
lvalue expressions that themselves read or write lvalues 

The function $CheckLValue(e, C, EQ)$ is similar to $Check$.  It takes the
same first 3 arguments as $Check$, except that $e$ evaluates to an lvalue.
It returns:
\begin{enumerate}
\item A bounds expression $B$ for the lvalues produced by $e$.
\item A bounds expression $RB$ for values read from the lvalues produced by $e$.
\item An updated context $\mathit{UC}$.
\item Updated sets of equivalent expressions $UEQ$.
\item A set of equivalent expressions $G$ that produce the same lvalue as $e$.
\item A set of non-modifying lvalue expressions $R$ that may be read during evaluation of $e$.
\item A set of non-modifying lvalue expressions $W$ that may be written during evaluation of $e$
\item It may also report an error.
\end{enumerate}

The definition of $Check(e, C, EQ, Form, FB)$ is:
\begin{enumerate}
\item If $e$ is an lvalue expression
\begin{enumerate}
\item Let $(B_{lv}, RB, \mathit{UC}, UEQ, G_{lv}, R_{lv}, W_{lv}) = CheckLValue(e, C, EQ,PV)$.
\item If $e$ has array type, let $B = B_{lv}$, $G = G_{lv}$, $R = R_{lv}$, and $W = W_{lv}$.
\item If $e$ does not have array type, there will an implicit read of the lvalue produced by $e$
at runtime:
\begin{enumerate}
\item If $W_{lv}$ is non-empty, check for read/write conflicts:
\begin{enumerate}
\item \item Let $nme$ by a non-modifying version of $e$: if $e$ is non-modifying, $nme = e$.  Otherwise,
let $nme$ by some element of $G_{lv}$.  If $G_{lv}$ is empty, signal an error.  TODO: can $G_{lv}$ be empty?$.
\item Call $CheckOverlap(\{nme\}, W_{lv})$ to make sure that the implicit read is not for
an lvalue that was already written during the evaluation of $e$.   That would be an unordered read/write.
\item If $NeedsBoundsCheck(e)$ returns true, a compiler will insert a bounds check 
to ensure $e$ is a valid memory location to access. Let $R_B$ be the set of lvalues read by $B_{lv}$.
Call $CheckOverlap(B_{lv}, W_{lv})$ to make sure that the bounds check isn't reading any lvalues
written during the evaluation of $e$.
\end{enumerate}
\item Let $B = RB$. 
\item Compute $G$:
\begin{enumerate}
\item If $nme$ is an element of a set of equivalent expressions $F$ in $EQ - W_{lv}$, let $G = F$. 
\item Otherwise, let $G = \{ nme \}$. 
end{enumerate}
\item Let $R = R_{lv} \cup R_B \cup nme$.  Let $W = W_{lv}$.
\end{enumerate}
\end{enumerate}

% lhs = rhs

\item If $e$ has the form $lhs = rhs$,
\label{list:check-assignment-struct}
\begin{enumerate}
\item Let $P_{lhs} = PV \cup Pending(rhs)$ and $P_{rhs} = PV \cup Pending(lhs).$   $P_{lhs}$
        and $P_{rhs}$ describe variables that are pending during the evaluations of $lhs$ and $rhs$.
\item Let $(B_{lhs}, RB, \mathit{UC}_{lhs}, {UEQ}_{lhs}, G_{lhs}, R_{rhs}, W_{rhs}) = CheckLValue(lhs, C, EQ)$.  
\item Let $(B_{rhs},  \mathit{UC}_{rhs}, {UEQ}_{rhs}, G_{rhs}, R_{rhs}, W_{rhs}) = 
Check(rhs, \mathit{UC}_{lhs}, {UEQ}_{lhs}, Form, RB)$.
\item If $NeedsBoundsCheck(lhs)$ returns true, check that $B_{lhs}$ does not use any variables in 
$PV \cup Pending(lhs) \cup Pending(rhs)$.  If it does, report an error.
\item  If $lhs$ is a variable $v$ (that is, $GetLValueVariable(lhs) = { v }$),
\begin{enumerate}
\item Check that $v \notin PV \cup Pending(lhs) \cup Pending(rhs)$.  If it is, report an error.  
There are multiple unsequenced assignments to $v$.
\item Choose an expression that computes the old value of $v$:
\begin{enumerate}
\item If $rhs$ can be inverted with respect to $v$, let $iv = inverse(v, rhs)$. 
\item Otherwise, if $EQ - (PV \cup Pending(lhs) \cup Pending(rhs))$ contains a set of equivalent expressions $F$ that contains $v$ as 
an element, and $F$ contains a variable $w \neq v$, set $iv$ to $w$.
\item Otherwise, let $iv = $ {\it None}.
\end{enumerate}
\item Let $(B, \mathit{UC}, UEQ, G) = Update(v, iv, B_{rhs}, \mathit{UC}_{rhs}, UEQ_{rhs}, G_{rhs})$.
\end{enumerate}
\item If $lhs$ is not a variable, let $(B, \mathit{UC}, UEQ, G) = (B_{rhs}, \mathit{UC}_{rhs}, UEQ_{rhs}, G_{rhs})$
\end{enumerate}

% lhs op= rhs

\item If $e$ has the form $lhs~op= rhs$, the result is 
$Check (lhs = lhs~op~rhs, C, EQ, PV, Compound, None)$.

\item For pre- and post-increment/decrement forms, if $e$ has the form:
\begin{enumerate}
\item \code{++}$e1$, the result is  $Check(e1$ \code{ = } $e1$ \code{ + 1}$,C, EQ, PV, 
Compound, None)$.
\item \code{--}$e1$, the result is $Check(e1$ \code{ = } $e1$ \code { - 1}$, C, EQ, PV,
Compound, None)$.
\item $e1$\code{++}, the result is  $Check(e1$ \code{ = } $ e1$ \code { + 1}$,
C, EQ, PV, PostIncDec, None)$.
\item $e1$\code{--}, the result is $Check(e1$ \code{ = } $ e1$ \code{ - 1}$, C, EQ, PV, PostIncDec, None)$.
\end{enumerate}
\item If $e$ has the form \code{&}$e1$, let $(B, \_, \mathit{UC}, UEQ, G) = CheckLValue(e1, C, EQ, PV)$.
      
\item Otherwise, $e$ is some expression with $n$ subexpressions (n may be 0).  The
result is 
\label{list:check-unordered-operands}
\begin{enumerate}
\item Let $\mathit{UC} = C$ and $UEQ = EQ$.  Let $S_k$ designate the $k^{th}$ subexpression.
\item Visit the $n$ subexpressions in some order, accumulating results into $\mathit{UC}$ and $UEQ$.  If the current subexpression being visited is $S_i$,
\begin{enumerate}
\item If $i = 1$ and $Form = PostIncDec$ or $Form = Compound$, $S_1$ has already
been checked, so use the results from that.  Let $B_1 = FB$.  If $S_1$ appears in some set $F$ in $UEQ$,
 let $G_1 = F$. Otherwise, let $G_1 = \emptyset$.
\item Otherwise, let $PV_i = PV \cup \bigcup_{j= 1, j <> i}^{n} Pending(S_j)$.
Let $(B_i, \_, \mathit{UC}, UEQ, G_i) =$  $Check(S_i, \mathit{UC}, UEQ, PV_i, No, None)$.
\end{enumerate}
\item Determine the set of equivalent expressions for $e$.  Recall that the equivalent expressions must be non-modifying expressions.
\begin{enumerate}
\item  If $Form = PostIncDec$, let $Val = S_1$.  Otherwise, let $Val = e$.
\item If $Val$ is a non-modifying expression, let $G  = \{ Val \}$.
\item If $Val$ is a call expression, let $G = \emptyset$.
\item Otherwise, try to construct a version $Val^\prime$ of $Val$ that computes the same value 
      as $Val$ but is a non-modifying expression. 
      
      For any subexpression $S_i$ that is a modifying expression, 
      use an expression from $G_i$ (or $G_1$ when $Form = PostIncDec$). If $G_i$ is empty, $Val^\prime$ cannot
      be constructed.
      
      Note that an invariant about each $G_i$ is that it will not contain any uses of variables in $PV_i$.
      This means that side-effects in other subexpressions do not affect the value of expressions in $G_i$.
\item If $Val^\prime$ can be constructed, let $G = \{ Val^\prime \}$.  Otherwise, let $G = \emptyset$.	
\end{enumerate}
\item Use the rules in Section~\ref{section:inferring-expression-bounds} to compute B using the $B_i$. 
\item If computing $B$ introduces a temporary $t$ to hold the value produced by evaluating $e$, add $t$ to $G$.
\end{enumerate}
\end{enumerate}



\subsection{Old stuff}

In Chapter~\ref{chapter:checking-bounds}, contexts map pointer variables to their bounds.
Contexts are extended to map structure variables to descriptions of bounds for their
members.  The bounds for members of a variable will be described using a set of pairs,
where the first element of each pair is a member path whose type is \arrayptr\
and the second element of each pair is a bounds expression.  The bounds expression may use 
variable member paths in addition to variables.

In Section~\ref{section:inferring-expression-bounds}, the inference of bounds for an
expression determines the bounds expression that applies to the value of the
expression.  For structure-typed expressions, inference is generalized to determine
the bounds expressions that apply to the \arrayptr\ members of the value 
of the expression.  This information is represented using the same
representation used for contexts: a set of pairs, where the first element 
is a member path whose type is \arrayptr\ and the second element is a 
bounds expression.  Given this representation, it is easy to define
the rules for inferring bounds for member accesses: a member access prunes the
set of pairs and shortens the member paths.

In Section~\ref{section:checking-complex-expressions}, checking of assignment
expressions updates contexts.  The contexts are then used to check that expression
statements imply declared bounds.  They are also used to check expressions nested
within an expression that contain assignment expressions. 
Given the representation of contexts, the rules for updating contexts
are extended to update contexts pointwise for structure variable assignments and member 
assignments.  For a structure variable assignment, the entire set of pairs for a
variable is updated.  For an assignment to a member of a  structure variable,
only the set of entries  associated with that member are updated.  Both forms of assignment
invalidate bounds expressions that use variable member paths that are changed by the
assignment.

An expression statement is checked by determining the updated context for the
expression statement, determining the expected context for bounds after 
the statement, and then checking that the updated context implies the
validity of the bounds in the expected context (Section ~\ref{section:checking-full-expressions}).
For each variable in the expected context, it is checked that the bounds expression in
the updated context implies the expected bounds expression.  This is easily 
extended to a structure variable by checking for each member path for 
the variable that the bounds expression in the updated context implies
the expected bounds expression.

\subsection{Determining contexts}

The context for every statement can be determined by using dataflow analyses extended
pointwise to structure variables.  Each structure variable is expanded into the set
of variable member paths that represent all \arrayptr-typed variable member paths beginning
with the variable.  First, an iterative forward dataflow analysis is done to determine the
member bounds state at every point in a function, following the rules in
Section~\ref{section:member-bounds-state-extent}.  The analysis works on the set of variable
member paths.   It computes for each variable member path whether the member bounds are valid 
at each program point.  It is a compile-time error if the analysis determines that the state of
member bounds is inconsistent along different paths.

Second, a generalized version of the extent dataflow analysis of Section~\ref{section:computing-extent}
is done.  Each structure variable is expanded into the set of variable
member paths that represent all \arrayptr-typed variable member paths begining with 
the variable.  The analysis assigns one lattice value to each of the variable member path for
each program point in the function where the variable is in scope.

The context for a statement is computed using the results of the dataflow analyses.
For each structure variable in scope for the statement, the set of \arrayptr-typed variable member paths 
beginning at the variable is determined.  The set is mapped to a set of pairs as follows:
\begin{itemize}
\item For the first element, the structure variable is removed from the beginning of the
path to create a member path.
\item For the second element, the extent dataflow analysis is consulted for the \arrayptr\ member path.
   If the bounds expression is not \boundsunknown, it is used.   If it is \boundsunknown, the result
   of the dataflow analysis for the member bounds state is examined. If the member bounds
   state is valid, the member bounds is used.  It is transformed to use variable member
   bounds by prefixing the member paths that occur in it with the structure variable.
   Otherwise, \boundsunknown\ is used.
\end{itemize}

\subsection{Inferring bounds for expressions without assignments}

This section describes extensions to Section~\ref{section:inferring-expression-bounds} for
determining bounds.   The notation \boundsinfer{\var{e}}{\var{s}} is overloaded for expressions
with structure types to mean that \var{e} has a set of member paths with individual bounds expressions.
\begin{itemize}
\item Variables: If \var{x} has a structure type, the context is consulted for \var{x} for
the set \var{s} of pairs of member paths and bounds expressions.  \boundsinfer{\var{x}}{\var{s}}.
\item Member access: Given an expression \var{e}\code{.}\var{m}, where \var{m} is 
a member name and \boundsinfer{\var{e}}{\var{s}},
\begin{itemize}
\item If \var{e}\code{.}\var{m} has a structure type, then
\begin{itemize}
\item The set $\var{s}^{\prime}$ is defined as follows.  For each pair 
      \texttt{(\var{mp}, \var{b})} in \var{s}, if \var{mp} has the form 
      \var{m}\code{.}\var{rp}, then \texttt{(\var{rp}, \var{b})} is
      included in $\var{s}^\prime$.
\item  Given $\var{s}^\prime$, \boundsinfer{\var{e}\code{.}\var{m}}{$\var{s}^\prime$}.
\end{itemize}
\item Otherwise,
\begin{itemize}
\item If $\var{s} = \texttt{\{(\var{m}, \var{b})\}}$, then \boundsinfer{\var{e}\code{.}\var{m}}{b}
\item Otherwise, \boundsinfer{\var{e}\code{.}\var{m}}{\boundsunknown}
\end{itemize}
\end{itemize}
\item Function calls: {\em To be filled in}
\end{itemize}

\subsection{Assignment expressions}

{\em To be filled in.}

\section{Compatibility of structure types with bounds declarations}

The C Standard defines compatibility of two structure types declared in
separate translation units \cite[Section 6.2.7]{ISO2011}.  This definition
is extended to include member bounds declarations and member bounds-safe
interfaces.  If the structure types are completed in both translation
units, for each pair of corresponding members,
\begin{itemize}
\item If the members have unchecked pointer type,
\begin{itemize}
\item If the members both have bounds-safe interfaces, the bounds-safe
interfaces must either both be bounds expressions or both be interface
types. If both have bounds expressions, the bounds expressions must be
syntactically identical after being placed into a canonical form.
If both have interface types, the interface types must be compatible.
\item Otherwise,  one member must have a bounds-safe interface and the
other member must omit a bounds-safe interface, or both members must omit
bounds-safe interfaces.
\end{itemize}
\item Otherwise, both members must have member bounds declarations or both
members must not have member bounds declarations.  If both members have
member bounds declarations, the bounds expressions must be syntactically
identical after being placed into canonical form.
\end{itemize}
