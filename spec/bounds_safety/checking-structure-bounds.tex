% !Tex root = checkedc.tex

\chapter{Checking bounds for structure types}
\label{chapter:checking-structure-bounds}

In this section, to simplify the presentation, it is assumed that none
of the local variables, parameters, or variable member paths that appear
in a bounds expression have their addresses taken. The prefix paths of
variable member paths cannot have their address taken also. The one
exception is that an address-taken variable or variable member path may
appear as the operand to an address (\&) operator on the right-hand side
of a bounds expression.  This lets us avoid complicating the explanation with the subtleties of
handling aliasing of variables. 
\omitted{Chapter~\ref{chapter:pointers-to-pointers} will discuss address-taken variables.}

\section{Bounds for expressions without assignments}

This section discusses expressions without assignments. It generalizes
Section~\ref{section:inferring-expression-bounds}
to handle variables of structure type. Generally, this
consists of allowing variable member paths to occur where variables
could occur. Variable member paths are a syntactic generalization of
variables: they consist of a variable or a variable with a sequence of
member access.

\subsection{Variable member paths}

If the variable member path is simply a variable, the rules in
Section~\ref{section:checking-variables}
 still apply. Otherwise, it is member path of the form
x.\var{path}, where x is a variable and \var{path} is a sequence of
one or more members separated by `.' operators.

\subsubsection{Paths with type \arrayptr}

If \var{x.path} has the type \arrayptr, the bounds information for
\var{x.path} is determined using 
Section~\ref{section:determining-variable-member-bounds}. If the resulting bounds
information is a bounds expression, it is used directly.

If the result is a member bounds, the result must be translated to a
variable-level bounds expression. Let \var{prefix} be \var{x.path} with the
last member access removed. Then for each member path \var{mp} that
occurs in the member bounds, substitute \var{prefix.mp} in place of mp
to create the variable-level bounds.

Consider the example:
\begin{verbatim}
struct S {
   array_ptr<int> data : count(num);
   int num;
};

void f(int len) {
    S y;
    int i, j;
    array_ptr<int> newarr : count(len) = (array_ptr<int>) malloc(sizeof(int) * len));
    y.data = newarr
    where suspends(y.data) && y.data : count(len);
    y.num = len
    where holds(y.data);   // the type-level invariant for y.data now holds
    z = y;
    â€¦
    i = z.data[0];
    j = y.data[0];
}
\end{verbatim}

For the assignment \texttt{i = z.data[0]}, the bounds for
\texttt{z.data} must be determined. The member bounds is \texttt{data:
count(num)}. In this case, the prefix of \texttt{z.data} is simply
\texttt{z}, so the member bounds is transformed to the variable-level
bounds \texttt{z.data : count(z.num)}.

For the assignment \texttt{j = y.data[0]}, the variable-level bounds
\texttt{y.data : count(len)} holds, in addition to the member bounds.
The variable-level bounds will be used, avoiding a load of the length
from \texttt{y.num}.

\subsection{Paths with type array}

If \var{x.path} has an array type with a known number of elements n,
such that \var{x.path} is being converted implicitly to a pointer type,
the bounds is:

\var{x.path} : bounds(\var{x.path}, \var{x.path} + n)

\subsection{Paths with structure type}

\emph{TODO: This type of expression produces an intermediate value that
needs a name. We will need to describe the variable-level bounds and the
state type-level invariants for individual members of this intermediate
value. It could be simple as saying that we create a variable whose name
is distinct from other variable names in the program and describe the
invariants in terms of members of that variable. The name `current'
could be a placeholder for the variable name.}

\subsection{Addresses of variable member paths}

A variable member path \var{p} whose address is taken is considered an
array of one element. It has the bounds:

\&p : bounds(\&p, \&p + 1)

\subsection{Function calls}

\emph{TODO: fill this in}

\section{Bounds for assignment expressions}

\emph{TODO: fill this in}
